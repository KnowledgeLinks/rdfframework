"""    This module is used for setting an intial test configs and values for 
the rdfframework """

import sys
import os
import pdb
import pprint
import json
import types

PACKAGE_BASE = os.path.abspath(
    os.path.split(
        os.path.dirname(__file__))[0])
print("PACKAGE_BASE: ", PACKAGE_BASE)
sys.path.append(PACKAGE_BASE)

from testconfig import config
from rdfframework.utilities import DictClass, pp, RdfNsManager, pp, \
                                   render_without_request, RdfConfigManager, \
                                   make_list, p_args
from rdfframework.rdfdatatypes import rdfdatatypes as rdt
from rdfframework.sparql import run_sparql_query
from rdfframework.framework import RdfFramework
from rdfframework.rdfdatasets import RdfDataset
import rdfframework.rdfclass
from rdfframework.rdfclass import test
print("CONFIG ---------------------------------------------------------------")
#config = DictClass(config)
# pp.pprint(config)
print("----------------------------------------------------------------------")
CFG = RdfConfigManager(config=config)
NSM = RdfNsManager(config=CFG)
rdf_defs = CFG.RDF_DEFINITIONS
pyrdf = rdt.pyrdf
sparql = render_without_request("sparqlClassDefinitionList.rq",
                                 graph=CFG.RDF_DEFINITION_GRAPH,
                                 prefix=NSM.prefix())
x = run_sparql_query(sparql, namespace=CFG.RDF_DEFINITIONS.namespace)
#pp.pprint([pyrdf(item['kdsClass']) for item in x])
_sparql = render_without_request("sparqlClassDefinitionDataTemplate.rq",
                                 prefix=NSM.prefix(),
                                 item_uri="bf:Topic",
                                 graph=CFG.RDF_DEFINITION_GRAPH)
z = run_sparql_query(_sparql, namespace=rdf_defs.namespace)

sparqldefs = render_without_request("sparqlAllRDFClassDefs.rq",
                                 graph=CFG.RDF_DEFINITION_GRAPH,
                                 prefix=NSM.prefix())
# print(sparqldefs)
y = run_sparql_query(sparqldefs, namespace=rdf_defs.namespace)

# h = RdfDataset
# def group_classess(data, group_key="kdsClass"):
#     rtn_obj = {}
#     for row in data:
#         try:
#             rtn_obj[.append(row)
ds = RdfDataset()
ds.load_data(z, strip_orphans=True, obj_method="list")
# ds.classes
#print(json.dumps(ds, indent=4))
# RdfFramework(reset=True)
def test2(self, prop):
    return getattr(self, prop)

class RdfClassMeta(type):
    @classmethod
    def __prepare__(*args, **kwargs):
        print('  RdfClassMeta.__prepare__(\n\t\t%s)' % (p_args(args, kwargs)))
        # pdb.set_trace()
        cls_defs = CFG.rdf_class_defs.get(args[1],{})
        doc_string = \
    """ %s: %s 
        ** autogenerated from knowledgelinks.io rdfframework rdf definitions

        attributes:
            %s""" % (args[1], cls_defs.get('rdf_label',''), "TBW")
        cls_defs['__doc__'] = doc_string
        cls_defs['test'] = test2
        return cls_defs



class RdfClassGenerator(object):
    def __init__(self):
        self.__get_defs()
        self.__make_defs()
        self.__make_classes()

    def __get_defs(self):
        sparqldefs = render_without_request("sparqlAllRDFClassDefs.rq",
                                            graph=CFG.RDF_DEFINITION_GRAPH,
                                            prefix=NSM.prefix())
        self.cls_defs_results = run_sparql_query(sparqldefs,
                                                 namespace=rdf_defs.namespace)

    def __make_defs(self):

        class_defs = {}
        for item in self.cls_defs_results:
            try:
                class_defs[item['kdsClass']['value']].append(item)
            except KeyError:
                class_defs[item['kdsClass']['value']] = [item]

        self.cls_defs = {NSM.pyuri(key):RdfDataset(value)
                         for key, value in class_defs.items()}
        CFG.__setattr__('rdf_class_defs', self.cls_defs, True)

    def __make_classes(self):
        # pdb.set_trace()
        for name in self.cls_defs.keys():
            setattr(rdfframework.rdfclass,
                    name, 
                    types.new_class(name,
                                    (dict,), 
                                    {'metaclass': RdfClassMeta}))

RdfClassGenerator()

test()
# import metalearning as m

# class bf_Topic(metaclass=m.Meta):
#      pass



